{"meta":{"title":"LoveMorgana's Blog","subtitle":"世上无难事,只怕有心人.","description":"世上无难事,只怕有心人.","author":"LiGang","url":"luoyupiaoshang.club"},"pages":[{"title":"About","date":"2018-02-07T17:17:33.868Z","updated":"2018-02-07T15:44:39.850Z","comments":true,"path":"about/index.html","permalink":"luoyupiaoshang.club/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-02-07T17:17:34.033Z","updated":"2018-02-07T15:44:39.912Z","comments":true,"path":"tags/index.html","permalink":"luoyupiaoshang.club/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-02-07T17:17:34.000Z","updated":"2018-02-07T15:44:39.881Z","comments":true,"path":"categories/index.html","permalink":"luoyupiaoshang.club/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库的基本操作","slug":"数据库的基本操作","date":"2018-01-01T11:59:06.000Z","updated":"2018-03-04T15:34:40.741Z","comments":true,"path":"2018/01/01/数据库的基本操作/","link":"","permalink":"luoyupiaoshang.club/2018/01/01/数据库的基本操作/","excerpt":"Mysql的基本操作….","text":"Mysql的基本操作…. RDBMS术语 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格. 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性. 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引. 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 mysql的数据类型目前我使用过的数据类型有 int varchar timestamp bigint smallint dater time year tinyint double 下面是标准数据库的类型 类型 大小 范围(有符号) 范围(无符号) 用途 TINYINT 1字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 时间类型 类型 大小 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038,结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16777215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16777215字节 中等长度文本数据 LONGBLOB 0-4294967295字节 二进制形式的极大文本数据 LONGTEXT 0-4294967295字节 极大文本数据 1234567891011CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。有4种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。这些对应4种BLOB类型，有相同的最大长度和存储需求。 创建数据库create database student; 使用此数据库use student; 创建数据库表123456789create table student_inf( `student_id` int not null auto_increment comment '学生ID', `student_name` VARCHAR(21) not null comment \"学生姓名\", `student_age` int not null comment \"学生年龄\", `student_birthday` DATE not null comment \"出生日期\", `create_time` timestamp not null default current_timestamp comment \"创建时间\", primary key(student_id), key idx_create_time(create_time) )ENGINE=Innodb auto_increment = 1000 DEFAULT charset = utf8 comment ='学生信息表'; 我们可以查看表的结构: 删除数据表drop table table_name; 查看表的字段 查看索引show index from stundet_inf;show keys from student_inf; 这两种方式都可以,查出来是2条索引. 索引类型创建索引时,可以规定索引能否包含重复值,如果不包含,则索引应该创建为Primary key或者unique类型的索引. 对于单列惟一性索引，这保证单列不包含重复的值。 对于多列惟一性索引，保证多个值的组合不重复。 创建索引实际上就是,在表中哪列上添加索引 alter table student_inf add index idx_student_age(student_age); 此时我们可以查看一下索引有没有增加: 删除索引我们其实并不需要idx_stundet_age这个索引.索引多了会拖慢查询速度.影响CPU的处理性能. 所以删除:drop index idx_student_age on student_inf 此时再查询,就会发现还剩2个索引. 或者alter table student_inf drop index idx_student_age.这样也可以. 删除主键的操作不长使用,alter table student_inf drop primary key 因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。 如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。 如果从表中删除了某列，则索引会受到影响。 对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。 如果删除组成索引的所有列，则整个索引将被删除。 插入语句 我们根据表的结构来进行insert 操作. 1insert into student_inf(student_id,student_name,student_age,student_birthday,create_time) values (null,'小明',12,'1995-05-02','2018-03-03 10:56:00'); update语句我们不小心犯错误了,把月份写成25月了. 所以采用下面的语句进行更新. 1update student_inf set student_birthday = '1995-02-02' where student_id =1000 ; 此时再看一下查询语句: 值得注意的是我们在生产环境中,不要使用select *来操作,这是查询表中所有的数据,会造成慢查询的问题. 删除语句delete from student_inf where student_id = 1000; 模糊查询 ##查看查询计划 我们可以看到查询用到了idx_create_time这个索引. Union操作符MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。 多个 SELECT 语句会删除重复的数据。 我们先来创建两个表 website表12345678910create table website( `website_id` int not null auto_increment comment '站点ID', `website_name` varchar(21) not null comment '站点名称', `website_url` varchar(100) not null comment '站点地址', `website_alexa` smallint not null comment '点击度排名', `website_country` VARCHAR(10) not null comment '站点服务维护所在国家', `create_time` timestamp not null default current_timestamp comment '创建时间', primary key(`website_id`), key idx_create_time(create_time) comment '创建间索引' )ENGINE=Innodb default charset =utf8; apps表123456789create table apps( `apps_id` int not null auto_increment comment '站点ID', `apps_name` varchar(21) not null comment '站点名称', `apps_url` varchar(100) not null comment '站点地址', `apps_country` VARCHAR(10) not null comment '站点服务维护所在国家', `create_time` timestamp not null default current_timestamp comment '创建时间', primary key(`apps_id`), key idx_create_time(create_time) comment '创建间索引' )ENGINE=Innodb default charset =utf8; 插入数据 插入website的数据 12345insert into website(website_id,website_name,website_url,website_alexa,website_country,create_time) values(null,'Google','https://www.google.cm/',1,'USA',null);insert into website(website_id,website_name,website_url,website_alexa,website_country,create_time) values(null,'淘宝','https://www.taobao.cm/',13,'CN',null);再编几个吧 插入apps表的数据 1insert into apps(apps_id,apps_name,apps_url,apps_country,create_time) values (null,'QQ APP','http://im.qq.com','CN',null); 3.使用union或者’union all’关键字来进行两个表之间的查询数据. 4.开始查询 union关键字的使用: union all 关键字的使用: 排序的使用(order by)下面的例子都是按照create_time来进行排序查询的. 倒序查询 正序查询 Mysql的分组(group by)查询GROUP BY 语句根据一个或多个列对结果集进行分组。 这个时候,我们来试试脚本运行的方法吧,换个样子肯定很舒服. 脚本如下,我们命名为schema.sql 123456789101112131415161718192021222324252627-- 选择你的目标数据库use mysqldemo;-- 开始执行下面的代码SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `employee_tbl`-- ----------------------------DROP TABLE IF EXISTS `employee_tbl`;CREATE TABLE `employee_tbl` ( `id` int(11) NOT NULL, `name` char(10) NOT NULL DEFAULT '', `date` datetime NOT NULL, `singin` tinyint(4) NOT NULL DEFAULT '0' COMMENT '登录次数', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of `employee_tbl`-- ----------------------------BEGIN;INSERT INTO `employee_tbl` VALUES ('1', '小明', '2016-04-22 15:25:33', '1'), ('2', '小王', '2016-04-20 15:25:47', '3'), ('3', '小丽', '2016-04-19 15:26:02', '2'), ('4', '小王', '2016-04-07 15:26:14', '4'), ('5', '小明', '2016-04-11 15:26:40', '4'), ('6', '小明', '2016-04-04 15:26:54', '2');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 我们使用一下图形化工具MysqlWorkBench吧. 步骤:1.我们首先要创建一个新的schema. 2.导入数据 3.点击按钮,我们创建成功. 在脚本上好歹也要写上自己的目标数据库吧. 参考地址如何使用mysqlworkbench导入mysql脚本 分组测试1.查询数据 2.执行分组 我们将以上的数据表按照名字进行分组,在统计每个人登录的次数. select name, SUM(singin) as singin_count from employee_tbl group by name with rollup 这个with rollup的作用就是可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）.就相当于加上了最终的总数计算, 我们再试试count()函数,并使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录： null表示所有人登录的总次数,用null来表示太难看看,所以我们用coalesce语法来设计一下: select coalesce(a,b,c) 参数说明： 如果a==null,则选择b；如果b==null,则选择c； 如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。 下面我们进行null的改写. mysql连接的使用一说连接,我们就要告别单表查询的时代了. Mysql的Join在两个或者多个表中查询数据. 可以在SELECT,UPDATE,DELETE语句中使用mysql的JOIN来联合多表查询. JOIN按照功能大致分为3类: 1231. inner join(内连接,或者等值连接):获取两个表中字段匹配关系的记录.2. Left join(左连接):获取左表所有记录,即使右表没有对应匹配的记录.3. Right join(右连接):与Left Join相反,用于获取右表所有记录,即使左表没有与之相匹配的数据. 既然需要关联两个表,我们就再设计一个student_sto12345678910create table student_scores( `student_id` int not null auto_increment comment '学生ID', `answer_person_name` VARCHAR(21) not null comment \"答题人姓名\", `math_scores` int not null comment \"数学成绩\", `language_scores` int not null comment \"语文成绩\", `physcial_score` int not null comment '物理成绩', `create_time` timestamp not null default current_timestamp comment \"创建时间\", primary key(student_id,answer_person_name), key idx_create_time(create_time) )ENGINE=Innodb auto_increment = 1000 DEFAULT charset = utf8 comment ='学生成绩表'; 这里我们用到了联合索引,且是用在了主键上.需要我们明白下面的意思: 123主键是唯一的。联合主键其实就是主键。只是联合主键是用2个或2个以上的字段组成主键。用这个主键包含的字段作为主键，这个组合在数据表中是唯一，且加了主键索引。 插入数据1insert into student_scores(student_id,answer_person_name,math_scores,language_scores,physcial_score,create_time)values(null,\"小红\",18,36,87,null); 1.和student_inf这张表做一个联合查询.我们先做’inner join’的实验. 12select s1.student_id,s1.student_name,s2.math_scores,s2.language_scores from student_inf s1 inner join student_scores s2 on s1.student_name = s2.answer_person_name;` 测试结果如下: 2.我们再做’left join’的实验. 1select s1.student_id,s1.student_name,s2.math_scores,s2.language_scores from student_inf s1 left join student_scores s2 on s1.student_name = s2.answer_person_name; 3.right join的测试 既然到这里,我们再深入一些,3表查询.也试一试吧.要不多没意思啊.又不是考试,但是我们要做到位.玩玩嘛. 再来一个表student_spending12345678910create table stundet_spending( student_id int not null auto_increment comment '学生ID', spending_person_name varchar(32) not null comment '消费者姓名', buy_book_spending int not null comment '买书钱', telephone_costs int not null comment '电话费', living_supplies_costs int not null comment '生活用品花费', create_time timestamp not null default current_timestamp comment '创建时间', primary key(student_id,spending_person_name), key idx_create_time(create_time))ENGINE=Innodb auto_increment = 1000 DEFAULT charset = utf8 comment ='学生花销表'; 插入数据 1insert into student_spending(student_id,spending_person_name,buy_book_spending,telephone_costs,living_supplies_costs,create_time) values(null,'小红',12,20,50,null); 我们来关联这3个表:1select s1.student_name,s1.student_age,s2.physcial_score,s3.buy_book_spending,s3.create_time from student_inf s1 inner join student_scores s2 on s1.student_name =s2.answer_person_name inner join student_spending s3 on s2.answer_person_name=s3.spending_person_name where s1.student_age = 18; mysql null 值处理MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。 为了处理这种情况，MySQL提供了三大运算符: IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。 在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。 MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。 好吧,我们做个试验: 建表: 12345create table runoob_test_tbl ( runoob_author varchar(40) NOT NULL, runoob_count INT ); 插入数据 1234INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('RUNOOB', 20);INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('菜鸟教程', NULL);INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('Google', NULL);INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values ('FK', 20); 查询 1SELECT * from runoob_test_tbl; 测试 1234mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count = NULL;Empty set (0.00 sec)mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count != NULL;Empty set (0.01 sec) 正确的测试 12SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL; mysql中,= 和 != 运算符是不起作用的; mysql的正则表达式MySQL中使用 REGEXP 操作符来进行正则表达式匹配。 1.查找runoob_author字段中以’st’为开头的所有数据：2.查找runoob_author字段以’OB’结尾的所有数据:3.查找runoob_author字段中所有内容包含O的所有数据: 4.查找runoob_author字段中以元音字符开头或以’OB’字符串结尾的所有数据： 正则表达式地址 Mysql的事务MySQL 事务主要用于处理操作量大，复杂度高的数据。 比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 事务必须满足ACID这4个条件分别为: 原子性（Atomicity，或称不可分割性）. 一致性（Consistency）. 隔离性（Isolation，又称独立性）. 持久性（Durability）. 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 注意在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制语句 BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 Mysql事务处理主要有两种方法有2种方法1.用BEGIN,ROLLBACK,COMMIT来实现 BEGIN开始一个事务 ROLLBACK事务回滚 COMMIT事务确认 2.直接用SET来改变Mysql的自动提交模式 SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 事务测试1.一个完整的事务如下: 2.我们来看看rollback情况. 再开始一个事务,特别之处是它没有提交.并被回滚了. 所以自然没有插进数据. 3.查看mysql的隔离级别 select @@tx_isolation 可见mysql的隔离级别默认是可重复读. Alter命令当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 我们先查看标的结构: 以下,2中查看方法是一致的. 删除,添加,或修改表字段.1.使用alter命令及drop字句删除表的i字段. alter table testalter_tbl drop i; 看一看更加全面的表结构.编码默认是gbk 2.增加一列 3.指定新增字段的位置. 执行下面的语句来测试,看看字段的位置有没有变化. 1234ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT FIRST;ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT AFTER c; 前两条SQL的执行结果: 后两条SQL的执行结果. 修改字段类型及名称. 改字段的类型 modify字段的使用. alter table testalter_tbl modify i bigint; 改字段的名称 字段名和类型全都改 5.解决对null值和默认值的影响 6.修改字段默认值 alter table testalter_tbl alter i set default 1000; 7.使用alter命令及drop字段来删除字段的默认值 8.修改数据表类型 alter table testalter_tbl engine = myisam; 9.修改表名ALTER TABLE testalter_tbl RENAME TO alter_tbl; 10.查看表的类型. show table status like &#39;testalter_tbl&#39;\\G; 索引MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。 上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 建立索引会占用磁盘空间的索引文件。 普通索引创建索引这是最基本的索引，它没有任何限制。它有以下几种创建方式： CREATE INDEX indexName ON mytable(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引)ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定123456789CREATE TABLE mytable(ID INT NOT NULL,username VARCHAR(16) NOT NULL,INDEX [indexName] (username(length))); 删除索引的语法DROP INDEX [indexName] ON mytable; 唯一索引它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定123456789CREATE TABLE mytable(ID INT NOT NULL,username VARCHAR(16) NOT NULL,UNIQUE [indexName] (username(length))); 使用ALTER 命令添加和删除索引有四种方式来添加数据表的索引： ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list): 该语句指定了索引为 FULLTEXT ，用于全文索引。 以下实例为在表中添加索引。 mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c); 你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引: mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c; 使用 ALTER 命令添加和删除主键主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：12mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); 你也可以使用 ALTER 命令删除主键： mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 显示索引信息你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \\G 来格式化输出信息。 尝试以下实例: mysql&gt; SHOW INDEX FROM table_name; \\G 临时表MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。 临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。 MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。 如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。 1234567891011121314151617181920mysql&gt; CREATE TEMPORARY TABLE SalesSummary ( -&gt; product_name VARCHAR(50) NOT NULL -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00 -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00 -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO SalesSummary -&gt; (product_name, total_sales, avg_unit_price, total_units_sold) -&gt; VALUES -&gt; ('cucumber', 100.25, 90, 2);mysql&gt; SELECT * FROM SalesSummary;+--------------+-------------+----------------+------------------+| product_name | total_sales | avg_unit_price | total_units_sold |+--------------+-------------+----------------+------------------+| cucumber | 100.25 | 90.00 | 2 |+--------------+-------------+----------------+------------------+1 row in set (0.00 sec) 当你使用 SHOW TABLES命令显示数据表列表时，你将无法看到 SalesSummary表。 如果你退出当前MySQL会话，再使用 SELECT命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。 删除临时表默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表。1234567891011121314151617181920212223mysql&gt; CREATE TEMPORARY TABLE SalesSummary ( -&gt; product_name VARCHAR(50) NOT NULL -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00 -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00 -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO SalesSummary -&gt; (product_name, total_sales, avg_unit_price, total_units_sold) -&gt; VALUES -&gt; ('cucumber', 100.25, 90, 2);mysql&gt; SELECT * FROM SalesSummary;+--------------+-------------+----------------+------------------+| product_name | total_sales | avg_unit_price | total_units_sold |+--------------+-------------+----------------+------------------+| cucumber | 100.25 | 90.00 | 2 |+--------------+-------------+----------------+------------------+1 row in set (0.00 sec)mysql&gt; DROP TABLE SalesSummary;mysql&gt; SELECT * FROM SalesSummary;ERROR 1146: Table 'RUNOOB.SalesSummary' doesn't exist 复制表如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用CREATE TABLE … SELECT 命令，是无法实现的。 本章节将为大家介绍如何完整的复制MySQL数据表，步骤如下： 使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。 复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。 如果你想复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现。 实例尝试以下实例来复制表 runoob_tbl 。12345678910111213141516171819202122232425262728293031323334353637383940414243444546步骤一：获取数据表的完整结构。mysql&gt; SHOW CREATE TABLE runoob_tbl \\G;*************************** 1. row *************************** Table: runoob_tblCreate Table: CREATE TABLE `runoob_tbl` ( `runoob_id` int(11) NOT NULL auto_increment, `runoob_title` varchar(100) NOT NULL default '', `runoob_author` varchar(40) NOT NULL default '', `submission_date` date default NULL, PRIMARY KEY (`runoob_id`), UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)) ENGINE=InnoDB1 row in set (0.00 sec)ERROR:No query specified步骤二：修改SQL语句的数据表名，并执行SQL语句。mysql&gt; CREATE TABLE `clone_tbl` ( -&gt; `runoob_id` int(11) NOT NULL auto_increment, -&gt; `runoob_title` varchar(100) NOT NULL default '', -&gt; `runoob_author` varchar(40) NOT NULL default '', -&gt; `submission_date` date default NULL, -&gt; PRIMARY KEY (`runoob_id`), -&gt; UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)-&gt; ) ENGINE=InnoDB;Query OK, 0 rows affected (1.80 sec)步骤三：执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 如果你想拷贝数据表的数据你可以使用 INSERT INTO... SELECT 语句来实现。mysql&gt; INSERT INTO clone_tbl (runoob_id, -&gt; runoob_title, -&gt; runoob_author, -&gt; submission_date) -&gt; SELECT runoob_id,runoob_title, -&gt; runoob_author,submission_date -&gt; FROM runoob_tbl;Query OK, 3 rows affected (0.07 sec)Records: 3 Duplicates: 0 Warnings: 0执行以上步骤后，你将完整的复制表，包括表结构及表数据。 mysql的元数据你可能想知道MySQL以下三种信息： 查询结果信息： SELECT, UPDATE 或 DELETE语句影响的记录数。 数据库和数据表的信息： 包含了数据库及数据表的结构信息。 MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等。在MySQL的命令提示符中，我们可以很容易的获取以上服务器信息。 但如果使用Perl或PHP等脚本语言，你就需要调用特定的接口函数来获取。 接下来我们会详细介绍。 获取查询语句影响的记录数PERL 实例在 DBI 脚本中， 语句影响的记录数通过函数 do( ) 或 execute( )返回：1234567891011# 方法 1# 使用do( ) 执行 $querymy $count = $dbh-&gt;do ($query);# 如果发生错误会输出 0printf \"%d 条数据被影响\\n\", (defined ($count) ? $count : 0);# 方法 2# 使用prepare( ) 及 execute( ) 执行 $querymy $sth = $dbh-&gt;prepare ($query);my $count = $sth-&gt;execute ( );printf \"%d 条数据被影响\\n\", (defined ($count) ? $count : 0); 数据库和数据表列表你可以很容易的在MySQL服务器中获取数据库和数据表列表。 如果你没有足够的权限，结果将返回 null。 你也可以使用 SHOW TABLES 或 SHOW DATABASES 语句来获取数据库和数据表列表。 REAL实例12345# 获取当前数据库中所有可用的表。my @tables = $dbh-&gt;tables ( );foreach $table (@tables )&#123; print \"表名 $table\\n\";&#125; 获取服务器元数据以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。 mysql的序列MySQL序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。 本章我们将介绍如何使用MySQL的序列。 使用AUTO_INCREMENTMySQL中最简单使用序列的方法就是使用 MySQL AUTO_INCREMENT 来定义列。 实例 以下实例中创建了数据表insect， insect中id无需指定值可实现自动增长。 123456789101112131415161718192021222324mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, # type of insect -&gt; date DATE NOT NULL, # date collected -&gt; origin VARCHAR(30) NOT NULL # where collected);Query OK, 0 rows affected (0.02 sec)mysql&gt; INSERT INTO insect (id,name,date,origin) VALUES -&gt; (NULL,'housefly','2001-09-10','kitchen'), -&gt; (NULL,'millipede','2001-09-10','driveway'), -&gt; (NULL,'grasshopper','2001-09-10','front yard');Query OK, 3 rows affected (0.02 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM insect ORDER BY id;+----+-------------+------------+------------+| id | name | date | origin |+----+-------------+------------+------------+| 1 | housefly | 2001-09-10 | kitchen || 2 | millipede | 2001-09-10 | driveway || 3 | grasshopper | 2001-09-10 | front yard |+----+-------------+------------+------------+3 rows in set (0.00 sec) 获取AUTO_INCREMENT值在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。 在PHP或PERL脚本中也提供了相应的函数来获取最后的插入表中的自增列的值。 PERL实例使用 mysql_insertid 属性来获取 AUTO_INCREMENT 的值。 实例如下：123$dbh-&gt;do (\"INSERT INTO insect (name,date,origin)VALUES('moth','2001-09-14','windowsill')\");my $seq = $dbh-&gt;&#123;mysql_insertid&#125;; 重置序列如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱 操作如下所示：1234mysql&gt; ALTER TABLE insect DROP id;mysql&gt; ALTER TABLE insect -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, -&gt; ADD PRIMARY KEY (id); 设置序列的开始值一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现：12345678mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, -&gt; date DATE NOT NULL, -&gt; origin VARCHAR(30) NOT NULL)engine=innodb auto_increment=100 charset=utf8; 或者你也可以在表创建成功后，通过以下语句来实现： mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100; MySQL 处理重复数据有些 MySQL 数据表中可能存在重复的记录，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。 本章节我们将为大家介绍如何防止数据表出现重复数据及如何删除数据表中的重复数据。 防止表中出现重复数据你可以在MySQL数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。 让我们尝试一个实例：下表中无索引及主键，所以该表允许出现多条重复记录。123456CREATE TABLE person_tbl( first_name CHAR(20), last_name CHAR(20), sex CHAR(10)); 如果你想设置表中字段first_name，last_name数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为NULL，可设置为NOT NULL。 如下所示：1234567CREATE TABLE person_tbl( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10), PRIMARY KEY (last_name, first_name)); 如果我们设置了唯一索引，那么在插入重复数据时，SQL语句将无法执行成功,并抛出错。 INSERT IGNORE INTO与INSERT INTO的区别就是INSERT IGNORE会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的 以下实例使用了INSERT IGNORE INTO，执行后不会出错，也不会向数据表中插入重复数据：123456mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name) -&gt; VALUES( 'Jay', 'Thomas');Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name) -&gt; VALUES( 'Jay', 'Thomas');Query OK, 0 rows affected (0.00 sec) INSERT IGNORE INTO当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而REPLACE INTO into如果存在primary 或 unique相同的记录，则先删除掉。再插入新记录 另一种设置数据的唯一性方法是添加一个UNIQUE索引，如下所示：1234567CREATE TABLE person_tbl( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10) UNIQUE (last_name, first_name)); 统计重复数据以下我们将统计表中 first_name 和 last_name的重复记录数：1234mysql&gt; SELECT COUNT(*) as repetitions, last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY last_name, first_name -&gt; HAVING repetitions &gt; 1; 以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作： 确定哪一列包含的值可能会重复。 在列选择列表使用COUNT(*)列出的那些列。 在GROUP BY子句中列出的列。 HAVING子句设置重复数大于1。 ###过滤重复数据 如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。12mysql&gt; SELECT DISTINCT last_name, first_name -&gt; FROM person_tbl; 你也可以使用 GROUP BY 来读取数据表中不重复的数据：123mysql&gt; SELECT last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY (last_name, first_name); 删除重复数据如果你想删除数据表中的重复数据，你可以使用以下的SQL语句： 12345mysql&gt; CREATE TABLE tmp SELECT last_name, first_name, sex -&gt; FROM person_tbl; -&gt; GROUP BY (last_name, first_name, sex);mysql&gt; DROP TABLE person_tbl;mysql&gt; ALTER TABLE tmp RENAME TO person_tbl; 当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。 方法如下：12mysql&gt; ALTER IGNORE TABLE person_tbl -&gt; ADD PRIMARY KEY (last_name, first_name); MySQL 及 SQL 注入如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。 本章节将为大家介绍如何防止SQL注入，并通过脚本来过滤SQL中注入的字符。 所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。 以下实例中，输入的用户名必须为字母、数字及下划线的组合，且用户名长度为 8 到 20 个字符之间：123456789if (preg_match(\"/^\\w&#123;8,20&#125;$/\", $_GET['username'], $matches))&#123; $result = mysqli_query($conn, \"SELECT * FROM users WHERE username=$matches[0]\");&#125; else&#123; echo \"username 输入异常\";&#125; 让我们看下在没有过滤特殊字符时，出现的SQL情况： 123// 设定$name 中插入了我们不需要的SQL语句$name = \"Qadir'; DELETE FROM users;\"; mysqli_query($conn, \"SELECT * FROM users WHERE name='&#123;$name&#125;'\"); 以上的注入语句中，我们没有对 $name 的变量进行过滤，$name 中插入了我们不需要的SQL语句，将删除 users 表中的所有数据。 在PHP中的 mysqli_query() 是不允许执行多个 SQL 语句的，但是在 SQLite 和 PostgreSQL 是可以同时执行多条SQL语句的，所以我们对这些用户的数据需要进行严格的验证。 防止SQL注入，我们需要注意以下几个要点：1234561.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双\"-\"进行转换等。2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 防止SQL注入在脚本语言，如Perl和PHP你可以对用户输入的数据进行转义从而来防止SQL注入。 PHP的MySQL扩展提供了mysqli_real_escape_string()函数来转义特殊的输入字符。123456if (get_magic_quotes_gpc())&#123; $name = stripslashes($name);&#125;$name = mysqli_real_escape_string($conn, $name); mysqli_query($conn, \"SELECT * FROM users WHERE name='&#123;$name&#125;'\"); Like语句中的注入like查询时，如果用户输入的值有&quot;_&quot;和&quot;%&quot;，则会出现这种情况：用户本来只是想查询&quot;abcd_&quot;，查询结果中却有&quot;abcd_&quot;、&quot;abcde&quot;、&quot;abcdf&quot;等等；用户要查询&quot;30%&quot;（注：百分之三十）时也会出现问题。 在PHP脚本中我们可以使用addcslashes()函数来处理以上情况，如下实例：1234$sub = addcslashes(mysqli_real_escape_string($conn, \"%something_\"), \"%_\");// $sub == \\%something\\_ mysqli_query($conn, \"SELECT * FROM messages WHERE subject LIKE '&#123;$sub&#125;%'\");addcslashes() 函数在指定的字符前添加反斜杠。 语法格式: addcslashes(string,characters)","categories":[{"name":"mysql","slug":"mysql","permalink":"luoyupiaoshang.club/categories/mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"luoyupiaoshang.club/tags/Mysql/"},{"name":"基本操作","slug":"基本操作","permalink":"luoyupiaoshang.club/tags/基本操作/"}]}]}